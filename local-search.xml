<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>提示词分享</title>
    <link href="/2025/07/22/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%88%86%E4%BA%AB/"/>
    <url>/2025/07/22/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>在分享自己的提示词之前，还有一些提示词库：</p><p><a href="https://linux.do/t/topic/392269">https://linux.do/t/topic/392269</a></p><p><a href="https://snackprompt.com/">https://snackprompt.com/</a></p><h1 id="论文润色并以markdown输出修改建议"><a href="#论文润色并以markdown输出修改建议" class="headerlink" title="论文润色并以markdown输出修改建议"></a>论文润色并以markdown输出修改建议</h1><div class="code-wrapper"><pre><code class="hljs markdown">请你扮演一个在学术论文耕耘百余年的专家，遣词造句学术化，完全没有口语化风格。请提供一个具体的英文或中文学术论文段落文本。然后，我需要你对这段文本进行全面打磨，使其符合学术写作风格。具体要求包括：1.不要出现“我们”，“具体而言”此类不符合学术化的词语2.修正拼写和语法错误。3.提高清晰度，确保逻辑流畅。4.增强简洁性，删除多余词句。5.提升整体可读性，使用正式的学术语气。6.如果必要，重写整个句子或段落，以保持原意的同时优化表达。7.千万要注意段落间句子的逻辑关系。8.当输出数学公式时，单美元符号表示行内公式，不要用行间公式。美元符号后的第一个符号不是空格，美元符号的前的第一个字符也不是空格。所有美元符号放到一行。公式最好合理分行。9.此外，在markdown表格中列出所有修改并解释修改的原因：</code></pre></div><hr><h1 id="在指定的期刊范围内查找文献"><a href="#在指定的期刊范围内查找文献" class="headerlink" title="在指定的期刊范围内查找文献"></a>在指定的期刊范围内查找文献</h1><div class="code-wrapper"><pre><code class="hljs md"><span class="hljs-section">## 可使用的工具</span><span class="hljs-bullet">-</span> 可使用Google Search，返回搜索结果<span class="hljs-bullet">-</span> 可使用Fetcher，获取网页内容<span class="hljs-section">### <span class="hljs-strong">**角色设定**</span>  你是一个专业的学术研究助手，擅长通过联网搜索精准定位高质量文献，并提取关键信息。  </span><span class="hljs-section">### <span class="hljs-strong">**核心指令**</span>  1. <span class="hljs-strong">**联网搜索要求**</span>：     - 根据用户提供的主题，使用上述工具从学术数据库（如Google Scholar、PubMed、IEEE Xplore等）或权威期刊网站进行检索。     具体可参考如下顶刊推荐：</span>数据挖掘顶级期刊IEEETKDE（IEEE Transactions on Knowledge and Data Engineering）http://www.ieee.org/organizations/pubs/transactions/tkde.htmDMKD（Data Mining and Knowledge Discovery） http://www.springerlink.com/content/1573-756X/?p=859c3e83455d41679ef1be783e923d1d&amp;pi=0ACMTKDD（ACM Transactions on Knowledge Discovery from Data）http://tkdd.cs.uiuc.edu/ACM TODS http://www.acm.org/tods/VLDB Journal http://www.vldb.org/ACM TOIS（ACM Transactions on Information Systems） http://www.acm.org/pubs/tois/ACM TIST（ACM Transactions on Intelligent Syetems and Technology）IEEE TNN（IEEE Transaction on Neural Networks）机器学习顶级期刊JMLRTPAMI, IJCV，MLJConferences汇总数据库三大顶级会议① SigMod http://www.acm.org/sigmod/② VLDB http://www.vldb.org/③ ICDE http://www.ipsi.fraunhofer.de/tcde/conf<span class="hljs-emphasis">_e.html</span><span class="hljs-emphasis">数据挖掘三大顶级会议</span><span class="hljs-emphasis">① SigKDDhttp://www.sigkdd.org/</span><span class="hljs-emphasis">② ICDMhttp://www.cs.uvm.edu/~icdm/</span><span class="hljs-emphasis">③ SDMhttp://www.siam.org/meetings/sdm07/</span><span class="hljs-emphasis">人工智能(+数据挖掘/计算机视觉/...) 国际顶级会议</span><span class="hljs-emphasis">① IJCAI ：人工智能领域顶级国际会议</span><span class="hljs-emphasis">② AAAI：美国人工智能学会AAAI的年会</span><span class="hljs-emphasis">③ PRICAI：亚太人工智能国际会议</span><span class="hljs-emphasis">机器学习国际顶级会议</span><span class="hljs-emphasis">① ICML：机器学习、模式识别领域顶级国际会议（综合）</span><span class="hljs-emphasis">② NIPS：神经计算，机器学习领域顶级国际会议（综合）</span><span class="hljs-emphasis">③ COLT：机器学习领域顶级国际会议（计算学习理论，理论计算机科学与机器学习的交叉）</span><span class="hljs-emphasis">计算机视觉顶级会议</span><span class="hljs-emphasis">① ICCV：两年一次，计算机视觉，模式识别，多媒体计算领域顶级会议</span><span class="hljs-emphasis">② CVPR：计算机视觉，模式识别，多媒体计算领域顶级会议</span><span class="hljs-emphasis">③ ECCV：两年一次，计算机视觉，模式识别，多媒体计算领域顶级会议</span><span class="hljs-emphasis">- <span class="hljs-strong">**验证文献真实性**</span>：确保文献来源为可信机构（如.edu、.gov、.org域名）或知名出版商（Elsevier、Springer、Nature）。  2. <span class="hljs-strong">**输出格式要求**</span>：     - <span class="hljs-strong">**第一步：汇总表格**</span>       以Markdown表格形式列出所有文献链接及内容摘要（一句话）。       </span><span class="hljs-emphasis">```markdown       | 序号 | 文献标题（链接） | 内容摘要 |       |------|------------------|----------|       | 1    | [<span class="hljs-string">标题</span>](<span class="hljs-link">URL</span>)      | 摘要...  |       ```     </span><span class="hljs-emphasis">- <span class="hljs-strong">**第二步：详细说明**</span>       按表格顺序展开每条文献的核心观点、研究方法及结论（每项不超过3句话）。</span><span class="hljs-emphasis">## 请注意</span><span class="hljs-emphasis">思考和查询用英文去搜索，回复要用中文回复</span></code></pre></div><hr><h1 id="画流程图草图"><a href="#画流程图草图" class="headerlink" title="画流程图草图"></a>画流程图草图</h1><div class="code-wrapper"><pre><code class="hljs md">请仔细阅读下面的文章，并按照以下步骤创建一个引人入胜且信息丰富的mermaid知识图解，以mermaid格式输出，注意检查空格，记得标点符号全部要用英文的半角，避免在不支持管道符的地方使用|：<span class="hljs-bullet">1.</span> 分析阶段：• 识别并提取文章中的核心概念、关键观点和它们之间的逻辑关系• 确定最适合表达这些内容的图解类型（思维导图、流程图、概念图、比较图等）• 考虑目标受众和他们的认知需求<span class="hljs-bullet">2.</span> 设计阶段：• 创建清晰的视觉层次结构，突出最重要的信息• 使用适当的视觉隐喻和符号，使抽象概念更容易理解• 应用一致的配色方案（3-5种互补色），增强可读性和美感• 平衡文字与视觉元素，确保简洁性和完整性• 使用视觉分组、对比和空间关系传达概念间的联系<span class="hljs-bullet">3.</span> 优化阶段：• 简化复杂信息，去除不必要的细节• 确保图解自成一体，无需原文也能传达完整信息• 验证图解是否准确反映了原文的核心思想请使用merid格式创建这个知识图解，确保它既能独立传达核心信息，又能以视觉上吸引人的方式呈现。图解应该是概念性的，而不仅是文本内容的重新排列。4.不要引用脚注，不需要出现脚注引用内容5.最后要检查一遍merid的整体格式，避免发生错误</code></pre></div><hr><h1 id="基础知识学习"><a href="#基础知识学习" class="headerlink" title="基础知识学习"></a>基础知识学习</h1><div class="code-wrapper"><pre><code class="hljs md">我正在学习[x]。请提供：简明扼要地解释[x]，包括其用途和常见实用场景，并给出具体的公式并解释。当输出数学公式时，单美元符号表示行内公式，不要用行间公式。美元符号后的第一个符号不是空格，美元符号的前的第一个字符也不是空格。所有美元符号放到一行。一个演示[x]的简单代码示例。初学者关于[x]常见的三个错误或误解，以及如何避免它们。两个关于[x]特别有用的实际应用场景或用例。 当输出数学公式时，单美元符号表示行内公式，不要用行间公式。美元符号后的第一个符号不是空格，美元符号的前的第一个字符也不是空格。所有美元符号放到一行。</code></pre></div><hr><h1 id="人人都有思维链"><a href="#人人都有思维链" class="headerlink" title="人人都有思维链"></a>人人都有思维链</h1><p>可从：<a href="https://blog.zhexuan.org/archives/anthropic_thinking_protocol.html">https://blog.zhexuan.org/archives/anthropic_thinking_protocol.html</a><br>获取</p><p><strong>可让非推理模型进行推理输出。</strong></p><hr><h1 id="提示词模板生成"><a href="#提示词模板生成" class="headerlink" title="提示词模板生成"></a>提示词模板生成</h1><div class="code-wrapper"><pre><code class="hljs md"><span class="hljs-section"># 角色设定（Role Definition）</span>你是一名提示词编写专家，你能理解用户的需求，编写出合适的,符合&lt;系统提示词结构&gt;的系统提示词(System<span class="hljs-emphasis">_Prompt)</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">&lt;系统提示词结构&gt; (<span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span>%d<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*在这个标识符之间的内容为示例）</span><span class="hljs-emphasis">    # 概述</span><span class="hljs-emphasis">    一个优秀的提示词应该包括以下几个部分：角色设定（Role Definition）、任务描述（Task Specification）、任务步骤（Task Steps）、约束条件（Constraints）、响应格式（Response Format）以及示例和指导（Examples and Guidance）。</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">    # 角色设定（Role Definition）</span><span class="hljs-emphasis">    明确模型在对话或任务中的角色，明确角色拥有技能与知识。 </span><span class="hljs-emphasis">    <span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span></span></span><span class="hljs-strong"><span class="hljs-emphasis">    你是一位资深的法律顾问，拥有10年的法律行业任职经验，擅长合同法。</span></span><span class="hljs-strong"><span class="hljs-emphasis">    <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">    # 任务描述（Task Specification）</span><span class="hljs-emphasis">    清晰地描述具体需要模型完成的任务。 </span><span class="hljs-emphasis">    <span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span></span></span><span class="hljs-strong"><span class="hljs-emphasis">    你需要根据用户给出的产品，写出爆款的营销文案，去吸引消费者购买产品。</span></span><span class="hljs-strong"><span class="hljs-emphasis">    <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">    # 任务步骤（Task Steps） Tips:这是最重要的部分，这个部分很大程度上决定了提示词能力的上限</span><span class="hljs-emphasis">    将任务分解，一步一步的把每一个步骤阐述，正如人类的思考流程一样，思考方式的类别有顺序、并行、跳跃、循环等。不同的任务决定了思考流程的区别，每一步任务如果不够简单，则需要分解成为更小的子任务。 <span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span></span></span><span class="hljs-strong"><span class="hljs-emphasis">    1. 统计文案字数，进行补充或压缩</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 确定文案的当前字数，如果超出或少于250到320字，进行相应的调整</span></span><span class="hljs-strong"><span class="hljs-emphasis"></span></span><span class="hljs-strong"><span class="hljs-emphasis">    2. 统计文案字数</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 确定文案的当前字数</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 如果超出或少于280到330字，则回到步骤1</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 如果在280到330字之间，则进入步骤3</span></span><span class="hljs-strong"><span class="hljs-emphasis"></span></span><span class="hljs-strong"><span class="hljs-emphasis">    3. 精简语言表达</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 确保文案简洁明了，短小精悍。避免冗余或重复，确保逗号之间的短句不超过13个字</span></span><span class="hljs-strong"><span class="hljs-emphasis"></span></span><span class="hljs-strong"><span class="hljs-emphasis">    4. 检查文案</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 检查整个文案，检查逗号之间的短句是否超过13个字</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 如果存在超过13个字的短语，则回到步骤3</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 如果所有的短语都在13个字以下，则进入步骤5</span></span><span class="hljs-strong"><span class="hljs-emphasis">    5. 格式化输出</span></span><span class="hljs-strong"><span class="hljs-emphasis">        - 按照输出格式进行输出</span></span><span class="hljs-strong"><span class="hljs-emphasis">    <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">    # 约束条件（Constraints） Tips:这也很重要，这个部分很大程度上决定了提示词的可用性与下限</span><span class="hljs-emphasis">    设定回答中的限制条件，确保模型在可控的范围内思考。 </span><span class="hljs-emphasis">    <span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span></span></span><span class="hljs-strong"><span class="hljs-emphasis">    1、你的回答不包含敏感信息或个人隐私</span></span><span class="hljs-strong"><span class="hljs-emphasis">    2、不要以大家好，朋友们好为开头</span></span><span class="hljs-strong"><span class="hljs-emphasis">    3、只输出答案，不要输出其他任何说明</span></span><span class="hljs-strong"><span class="hljs-emphasis">    <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">    # 响应格式（Response Format）</span><span class="hljs-emphasis">    指示模型以特定的格式返回结果，确保输出符合预期的结构。</span><span class="hljs-emphasis">    <span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span></span></span><span class="hljs-strong"><span class="hljs-emphasis">    简单叙述每一个思考步骤，把最终结果包裹在<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span></span>之间</span></span><span class="hljs-strong"><span class="hljs-emphasis">    <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*</span><span class="hljs-emphasis">    <span class="hljs-strong">***<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span></span></span></span><span class="hljs-strong"><span class="hljs-emphasis">    以字典格式输出结果，包括以下key：`主要信息`、`核心内容`、`主题`、`目的`、`目标受众`、`风格`、`语调`、`作者的情感态度`、`情感表达`。请务必符合JSON格式</span></span><span class="hljs-strong"><span class="hljs-emphasis">    <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span></span>**</span>*</span><span class="hljs-emphasis">    当然，对于需要输出Dict格式，你也可以直接给出JSON Schema，那是最好的</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">    # 示例和指导（Examples and Guidance）</span><span class="hljs-emphasis">    提供示例或进一步的指导，有助于模型更好地理解任务要求。可以提供一个高质量回答的范例或者说明需要避免的常见错误或误区。</span><span class="hljs-emphasis">&lt;/系统提示词结构&gt;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis"># 任务描述（Task Specification）</span><span class="hljs-emphasis">你需要不断地跟用户进行沟通，明确用户的具体需求，然后分析，分解整个需求，拆分成细分任务，最终根据&lt;系统提示词结构&gt;，构建出完整的系统提示词</span><span class="hljs-emphasis"></span><span class="hljs-emphasis"># 任务步骤（Task Steps）</span><span class="hljs-emphasis">1.理解用户需求</span><span class="hljs-emphasis">2.检查需求是否完整与详细</span><span class="hljs-emphasis">  - 需求不完整或不够详细，与用户交流完善需求</span><span class="hljs-emphasis">  - 需求完整，进入步骤3</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">3.梳理需求，根据&lt;系统提示词结构&gt;给出合适的 角色设定（Role Definition）、任务描述（Task Specification）</span><span class="hljs-emphasis">4.仔细思考整个需求的流程，将大的流程拆分成一个个小流程，根据&lt;系统提示词结构&gt;选择合适的思维模式，编写出完善的思维链，给出任务步骤（Task Steps）</span><span class="hljs-emphasis">5.测试步骤4中给出的思维链，找出可能存在的漏洞或思维偏差，按照客户的需求，根据&lt;系统提示词结构&gt;给出完善的约束条件（Constraints）</span><span class="hljs-emphasis">6.根据用户的需求，给出合适的响应格式（Response Format）</span><span class="hljs-emphasis">7.检查步骤1-6给出的提示词，结合用户需求，按需根据&lt;系统提示词结构&gt;给出示例和指导（Examples and Guidance）</span><span class="hljs-emphasis">8.按照下面的响应格式（Response Format），给出完整的系统提示词(System_</span>Prompt)<span class="hljs-section"># 约束条件（Constraints）</span>1.在彻底了解用户的需求前，你需要持续与用户交流完善需求2.在任务步骤中，如果当前需求不足以让你清晰，准确的完成步骤，请停止步骤，并与用户交流完善需求，直至需求满足你的要求后才继续思考。3.只输出完整的系统提示词，不要输出其他任何说明<span class="hljs-section"># 响应格式（Response Format）</span>系统提示词包括角色设定（Role Definition）、任务描述（Task Specification）、任务步骤（Task Steps）、约束条件（Constraints）、响应格式（Response Format）以及示例和指导（Examples and Guidance），其中示例和指导是可选的。每一部分以“# ”开头，在标题结束后，进行换行，然后再填充部分内容，每一部分之间都要空出一行</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>高效技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二篇论文</title>
    <link href="/2025/06/05/%E7%AC%AC%E4%BA%8C%E7%AF%87%E8%AE%BA%E6%96%87/"/>
    <url>/2025/06/05/%E7%AC%AC%E4%BA%8C%E7%AF%87%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1-研究背景与目标"><a href="#1-研究背景与目标" class="headerlink" title="1. 研究背景与目标"></a>1. 研究背景与目标</h4><p>FSDBWO 是一种高效的混合特征选择算法，结合了 Relief-F 和 FSDBWO 两阶段解决方案，旨在解决高维数据中的维度灾难问题。研究通过广泛的实验评估，验证了 FSDBWO 算法在特征选择问题中的有效性，特别是在高维数据集上的表现。</p><h4 id="2-算法框架与创新点"><a href="#2-算法框架与创新点" class="headerlink" title="2. 算法框架与创新点"></a>2. 算法框架与创新点</h4><ul><li><strong>算法设计</strong>：FSDBWO 整合了特定的优化机制（食物充足策略），对传统的黑寡妇优化算法（BWO）进行了改进，以更高效地处理特征选择问题。整体的算法流程图如下：<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.3gop3uz0zc.webp"></li><li><strong>变异策略</strong>: 针对随机变异和定向变异，给出了可视化的解释：~<a href="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.6t7ey8g03r.webp"></a></li><li><strong>再生策略</strong>: 特征选择的本质是保证高质量特征子集的情况下，特征子集越小越好，因此分析了Levy初始化策略相比混沌初始化策略的优势：<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.5mo3pmrcil.webp"></li><li><strong>参数优化</strong>：研究特别分析了特征选择参数（fs）对算法性能的影响。实验结果显示，在多个数据集（如 LSVT_voice、Prostate、CrohnDisease）上，fs&#x3D;3 时算法表现最佳，分类错误率和适应度值均较低。</li><li><strong>适用性</strong>：FSDBWO 在高维数据集中表现出色，能够快速识别并剔除次优特征，从而发现最优或近最优特征子集。</li></ul><h4 id="3-实验结果与性能分析"><a href="#3-实验结果与性能分析" class="headerlink" title="3. 实验结果与性能分析"></a>3. 实验结果与性能分析</h4><ul><li><strong>数据集与对比方法</strong>：实验在10个数据集上进行，特征数量从60到24,482不等，涵盖了 UCI 机器学习库中的数据集（如 LSVT_voice、Musk、Sonar）以及高维微阵列表达数据集。FSDBWO 与8种特征选择算法（包括 BWO、PSO、JADE、MRFO、SMA、WOA 以及两种最新方法 HLBDA 和 FTGGA）进行了对比。</li><li><strong>性能表现</strong>：FSDBWO 在大多数情况下优于6种经典算法和2种最新方法，尤其在高维数据集上表现突出。例如，在 Worst FSP 指标上，FSDBWO 在所有数据集上均排名第一。<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.1sfc6oc3zn.webp"></li><li><strong>分类准确率</strong>：通过 Random Forest 分类器进行补充实验，FSDBWO 的分类准确率在10个数据集上的 Best、Mean 和 Worst 结果均表现优异，进一步验证了其有效性。<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.70amto3i8r.webp"></li><li><strong>收敛速度</strong>: 收敛图可以显著的表现出各个算法的收敛状况：<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.8hgrvf87mn.webp"></li><li><strong>训练时间</strong>: 统计了各个算法在数据集上的训练时间：<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.wiur82qpl.webp"></li><li><strong>统计显著性</strong>：通过 Wilcoxon 秩和检验，FSDBWO 在多个数据集上的特征选择性能（FSP）与其他算法相比具有统计显著性，p 值普遍低于 0.05，表明其改进效果显著。</li><li><strong>具体数据集表现</strong>：在 LSVT_voice 数据集上，fs&#x3D;3 时 FSDBWO 的 FSP、错误率和适应度值均达到最优；在 Prostate 和 CrohnDisease 数据集上，fs&#x3D;3 同样表现出色。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇论文</title>
    <link href="/2024/05/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87/"/>
    <url>/2024/05/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1-研究背景与目标"><a href="#1-研究背景与目标" class="headerlink" title="1. 研究背景与目标"></a>1. 研究背景与目标</h4><p>DEF-FM 是一种基于差分进化（Differential Evolution, DE）算法改进的框架，旨在提升算法性能，特别是在特征选择等离散问题中的表现。研究通过系统性实验验证了 DEF-FM 的有效性，重点解决传统 DE 算法易陷入局部最优的问题。</p><h4 id="2-算法框架与创新点"><a href="#2-算法框架与创新点" class="headerlink" title="2. 算法框架与创新点"></a>2. 算法框架与创新点</h4><ul><li><p><strong>算法原理与改进策略</strong>：DEF-FM 通过引入特定的改进机制（如调整框架以避免陷入局部最优），对传统 DE 算法进行了优化。原理是依据水力学的层流、过渡流、湍流理论，如下图所示<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.9o03409021.webp" alt="图1"><br>论文中详细描述了其原理，并通过伪代码（Algorithm 2）<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.7i0oi8szfq.webp"> </p><p>和流程图（Fig. 2）<img src="https://jsd.cdn.zzko.cn/gh/humertank0/picx-images-hosting@master/20250720/image.83ac4jcm9y.webp">直观展示了框架的运作方式。</p></li><li><p><strong>避免早熟收敛</strong>：通过调整算法的停滞步数（stagnation steps）进入湍流阶段（turbulent flow stage），DEF-FM 降低了算法早熟收敛的风险。较小的停滞步数能够更积极地优化算法性能。</p></li></ul><h4 id="3-实验结果与性能分析"><a href="#3-实验结果与性能分析" class="headerlink" title="3. 实验结果与性能分析"></a>3. 实验结果与性能分析</h4><ul><li><strong>分类准确率提升</strong>：在多个数据集（如 CNAE-9、LSVT_voice、Musk 等）上，DEF-FM 相较于传统 DE 算法在分类准确率上表现出显著优势。例如，在 CNAE-9 数据集上，DEF-FM 的最佳准确率从 0.81667 提升至 0.84074，均值准确率也有所提高。</li><li><strong>适应度比较</strong>：DEF-FM 在适应度（Fitness）指标上同样优于 DE 算法，尤其在均值和最差适应度上表现出更好的稳定性。例如，在 CNAE-9 数据集上，DEF-FM 的平均适应度从 0.32218 改善至 0.31942。</li><li><strong>时间消耗分析</strong>：尽管 DEF-FM 在运行时间上略有增加，但对整体时间复杂度的影响有限。例如，在 CNAE-9 数据集上，DE 的平均运行时间为 599.704 秒，而 DEF-FM 为 640.129 秒，性能提升远超时间成本。</li><li><strong>统计显著性</strong>：通过 Wilcoxon 检验，DEF-FM 在多个数据集上的准确率提升具有统计显著性，p 值普遍低于 0.05，表明其改进效果并非偶然。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo设置指南</title>
    <link href="/2023/11/18/hexo%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/18/hexo%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo的设置指南"><a href="#hexo的设置指南" class="headerlink" title="hexo的设置指南"></a>hexo的设置指南</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>可以使用npm一键安装脚本。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 对于windows用户，直接去官网下载node.js，安装后设置path</span>https://nodejs.org/en/download<span class="hljs-comment"># 对于Debian系的Linux，如Ubuntu，可以使用apt安装</span>sudo apt install npm<span class="hljs-comment"># 对于ArchLinux，可以使用pacman安装</span>sudo pacman -Sy npm</code></pre></div><p>安装hexo</p><div class="code-wrapper"><pre><code class="hljs bash">npm install -g hexo-cli</code></pre></div><p>确认安装完成，查看版本号</p><div class="code-wrapper"><pre><code class="hljs bash">hexo -v<span class="hljs-comment">#INFO  Validating config</span><span class="hljs-comment"># hexo: 6.3.0</span><span class="hljs-comment"># hexo-cli: 4.3.1</span><span class="hljs-comment"># os: win32 10.0.22631</span><span class="hljs-comment"># node: 20.9.0</span><span class="hljs-comment"># acorn: 8.10.0</span><span class="hljs-comment"># ada: 2.6.0</span><span class="hljs-comment"># ares: 1.19.1</span><span class="hljs-comment"># base64: 0.5.0</span><span class="hljs-comment"># brotli: 1.0.9</span><span class="hljs-comment"># cjs_module_lexer: 1.2.2</span><span class="hljs-comment"># cldr: 43.1</span><span class="hljs-comment"># icu: 73.2</span><span class="hljs-comment"># llhttp: 8.1.1</span><span class="hljs-comment"># modules: 115</span><span class="hljs-comment"># napi: 9</span><span class="hljs-comment"># nghttp2: 1.57.0</span><span class="hljs-comment"># nghttp3: 0.7.0</span><span class="hljs-comment"># ngtcp2: 0.8.1</span><span class="hljs-comment"># openssl: 3.0.10+quic</span><span class="hljs-comment"># simdutf: 3.2.17</span><span class="hljs-comment"># tz: 2023c</span><span class="hljs-comment"># undici: 5.26.3</span><span class="hljs-comment"># unicode: 15.0</span><span class="hljs-comment"># uv: 1.46.0</span><span class="hljs-comment"># uvwasi: 0.0.18</span><span class="hljs-comment"># v8: 11.3.244.8-node.16</span><span class="hljs-comment"># zlib: 1.2.13.1-motley</span></code></pre></div><h1 id="2-创建项目hexo并初始化"><a href="#2-创建项目hexo并初始化" class="headerlink" title="2. 创建项目hexo并初始化"></a>2. 创建项目<strong>hexo</strong>并初始化</h1><div class="code-wrapper"><pre><code class="hljs bash">hexo init hexo<span class="hljs-built_in">cd</span> hexonpm install</code></pre></div><h1 id="3-本地启动"><a href="#3-本地启动" class="headerlink" title="3. 本地启动"></a>3. 本地启动</h1><div class="code-wrapper"><pre><code class="hljs bash">hexo g //hexo generatehexo server</code></pre></div><p>本地服务启动，端口号是4000，打开浏览器输入</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:4000</span></code></pre></div><h1 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4. 更换主题"></a>4. 更换主题</h1><p>主题可以从<a href="https://hexo.io/themes/">官网</a>找自己喜欢的。本文以<strong>Next</strong>为例。</p><p>安装主题,在根目录下面的themes文件夹中,将克隆的文件放到&#x2F;themes&#x2F;next文件夹中。</p><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> hexo-bloggit clone https://github.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">next</span>-theme/hexo-theme-<span class="hljs-keyword">next</span>.git themes/<span class="hljs-keyword">next</span></code></pre></div><p>从根目录找到_config.yml文件，在文件中找到<strong>theme</strong>字段，修改为<strong>next</strong>。</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-meta"># theme: landscape</span>theme: <span class="hljs-keyword">next</span></code></pre></div><p>本地启动，进行测试。</p><div class="code-wrapper"><pre><code class="hljs bash">hexo g //hexo generatehexo server</code></pre></div><h1 id="5-创建文章"><a href="#5-创建文章" class="headerlink" title="5.创建文章"></a>5.创建文章</h1><p>打开根目录中的 _config.yml进行确认，为了在生成文章的时候生成一个同名的资源目录用于存放图片文件</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span></code></pre></div><p>使用如下命令，创建一篇新文章，名为“test”</p><div class="code-wrapper"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> test</code></pre></div><p>关于图片的引用，可参考<a href="https://hexo.io/zh-cn/docs/asset-folders.html">官方文档</a></p><p>下面给出了三种引用方式：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">test</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-11-18 19:14:26</span><span class="hljs-attr">tags:</span><span class="hljs-bullet">-</span> <span class="hljs-string">test</span><span class="hljs-meta">---</span><span class="hljs-meta"></span><span class="hljs-string">This</span> <span class="hljs-string">paper</span> <span class="hljs-string">is</span> <span class="hljs-string">used</span> <span class="hljs-string">for</span> <span class="hljs-string">testing.</span>&#123;<span class="hljs-string">%</span> <span class="hljs-string">asset_img</span> <span class="hljs-string">test.png</span> <span class="hljs-string">图片引用方法一</span> <span class="hljs-string">%</span>&#125;<span class="hljs-type">![</span><span class="hljs-string">图片引用方法二](test.png)</span><span class="hljs-type">![</span><span class="hljs-string">图片引用方法三](/images/test.png)</span></code></pre></div><h1 id="6-页面细节改动"><a href="#6-页面细节改动" class="headerlink" title="6. 页面细节改动"></a>6. 页面细节改动</h1><p>页面的细节改动，主要从_config.yml文件中进行修改。具体的自定义修改可查看<a href="https://hexo.io/docs/">官方文档</a></p><h1 id="7-发布到githubPages"><a href="#7-发布到githubPages" class="headerlink" title="7.发布到githubPages"></a>7.发布到githubPages</h1><p>安装hexo-deployer-git</p><div class="code-wrapper"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span></code></pre></div><p>修改_config.yml文件，配置github信息</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><span class="hljs-symbol">    type:</span> git<span class="hljs-symbol">    repo:</span> https:<span class="hljs-comment">//github.com/your-github-id/your-github-id.github.io.git</span><span class="hljs-symbol">    branch:</span> main<span class="hljs-symbol">    token:</span> (githubPagesToken)</code></pre></div><p>token需要从GitHub获取，并授予token管理库的权限。<br>设置完毕后，执行部署命令</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span></code></pre></div><p>建议先本地测试，再进行部署</p><div class="code-wrapper"><pre><code class="hljs scss">hexo cleanhexo <span class="hljs-built_in">g</span>(enerate)hexo <span class="hljs-built_in">s</span>(erver)# 本地测试通过后hexo <span class="hljs-built_in">d</span>(eploy)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写入excel表格</title>
    <link href="/2023/11/18/%E5%86%99%E5%85%A5excel%E8%A1%A8%E6%A0%BC/"/>
    <url>/2023/11/18/%E5%86%99%E5%85%A5excel%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="将数据写入-excel-表格"><a href="#将数据写入-excel-表格" class="headerlink" title="将数据写入 excel 表格"></a>将数据写入 excel 表格</h1><p>用的是 xlrd 和 xlwt，由于需要频繁开关xls文件，不适合连续写入，建议 <strong>openpyxl</strong> 库，后续会进行更新。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># coding=UTF-8</span><span class="hljs-keyword">import</span> xlrd<span class="hljs-keyword">import</span> xlwt<span class="hljs-keyword">from</span> xlutils.copy <span class="hljs-keyword">import</span> copy  <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_excel_xls</span>(<span class="hljs-params">path, sheet_name, value</span>):    index = <span class="hljs-built_in">len</span>(value)  <span class="hljs-comment"># 获取需要写入数据的行数</span>    workbook = xlwt.Workbook()  <span class="hljs-comment"># 新建一个工作簿</span>    sheet = workbook.add_sheet(sheet_name)  <span class="hljs-comment"># 在工作簿中新建一个表格</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, index):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(value[i])):            sheet.write(i, j, value[i][j])  <span class="hljs-comment"># 像表格中写入数据（对应的行和列）</span>    workbook.save(path)  <span class="hljs-comment"># 保存工作簿</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xls格式表格写入数据成功！&quot;</span>)  <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_excel_xls_append</span>(<span class="hljs-params">path, value</span>):    index = <span class="hljs-built_in">len</span>(value)  <span class="hljs-comment"># 获取需要写入数据的行数</span>    workbook = xlrd.open_workbook(path)  <span class="hljs-comment"># 打开工作簿</span>    sheets = workbook.sheet_names()  <span class="hljs-comment"># 获取工作簿中的所有表格</span>    worksheet = workbook.sheet_by_name(sheets[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 获取工作簿中所有表格中的的第一个表格</span>    rows_old = worksheet.nrows  <span class="hljs-comment"># 获取表格中已存在的数据的行数</span>    new_workbook = copy(workbook)  <span class="hljs-comment"># 将xlrd对象拷贝转化为xlwt对象</span>    new_worksheet = new_workbook.get_sheet(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 获取转化后工作簿中的第一个表格</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, index):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(value[i])):            new_worksheet.write(i+rows_old, j, value[i][j])  <span class="hljs-comment"># 追加写入数据，注意是从i+rows_old行开始写入</span>    new_workbook.save(path)  <span class="hljs-comment"># 保存工作簿</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xls格式表格【追加】写入数据成功！&quot;</span>)  <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_excel_xls</span>(<span class="hljs-params">path</span>):    workbook = xlrd.open_workbook(path)  <span class="hljs-comment"># 打开工作簿</span>    sheets = workbook.sheet_names()  <span class="hljs-comment"># 获取工作簿中的所有表格</span>    worksheet = workbook.sheet_by_name(sheets[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 获取工作簿中所有表格中的的第一个表格</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, worksheet.nrows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, worksheet.ncols):            <span class="hljs-built_in">print</span>(worksheet.cell_value(i, j), <span class="hljs-string">&quot;\t&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># 逐行逐列读取数据</span>        <span class="hljs-built_in">print</span>()  book_name_xls = <span class="hljs-string">&#x27;xls格式测试工作簿.xls&#x27;</span> sheet_name_xls = <span class="hljs-string">&#x27;xls格式测试表&#x27;</span> value_title = [[<span class="hljs-string">&quot;姓名&quot;</span>, <span class="hljs-string">&quot;性别&quot;</span>, <span class="hljs-string">&quot;年龄&quot;</span>, <span class="hljs-string">&quot;城市&quot;</span>, <span class="hljs-string">&quot;职业&quot;</span>],] value1 = [[<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;19&quot;</span>, <span class="hljs-string">&quot;杭州&quot;</span>, <span class="hljs-string">&quot;研发工程师&quot;</span>],          [<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;医生&quot;</span>],          [<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;33&quot;</span>, <span class="hljs-string">&quot;珠海&quot;</span>, <span class="hljs-string">&quot;出租车司机&quot;</span>],] value2 = [[<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>, <span class="hljs-string">&quot;测试工程师&quot;</span>],          [<span class="hljs-string">&quot;Jones&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;34&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;产品经理&quot;</span>],          [<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;56&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;教师&quot;</span>],]  write_excel_xls(book_name_xls, sheet_name_xls, value_title)write_excel_xls_append(book_name_xls, value1)write_excel_xls_append(book_name_xls, value2)read_excel_xls(book_name_xls)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python命名规范</title>
    <link href="/2023/11/18/python%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2023/11/18/python%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>Google Python 命名规范</p><p>常用</p><div class="code-wrapper"><pre><code class="hljs python">模块名写法: module_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">包名写法: package_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">类名: ClassName ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">方法名: method_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">异常名: ExceptionName ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">函数名: function_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">全局常量名: GLOBAL_CONSTANT_NAME ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">全局变量名: global_var_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">实例名: instance_var_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">函数参数名: function_parameter_name ;</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">局部变量名: local_var_name.函数名,变量名和文件名应该是描述性的,尽量避免缩写,特别要避免使用非项目人员不清楚难以理解的缩写,不要通过删除单词中的字母来进行缩写.始终使用.py作为文件后缀名,不要用破折号.</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速搜索</title>
    <link href="/2018/08/10/%E5%BF%AB%E9%80%9F%E6%90%9C%E7%B4%A2/"/>
    <url>/2018/08/10/%E5%BF%AB%E9%80%9F%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>在处理大量文件和数据的时候，快速搜索工具可以帮助我们提高效率。以下是一些常用的快速搜索工具</p><ul><li><a href="https://www.voidtools.com/">Everything</a><blockquote><p>这是一款Windows上的搜索引擎软件，可以快速搜索本地磁盘文件。它占用内存小，搜索界面简单，搜索速度又快，而且完全免费，还能够基于文件名快速锁定文件和文件夹位置，搜索时也只需输入文件夹或文件的关键字。</p></blockquote></li><li><a href="https://www.listary.com/">Listary</a><blockquote><p>这是一个第三方文件搜索工具，搜索速度比Windows自带的搜索要快很多。安装完软件后，在任意场景下，连续敲击两下键盘的Ctrl键，Listary的文件搜索框就会出现。除了文件搜索功能，Listary还可以实现在特定网站中搜索关键词。</p></blockquote></li></ul><p>然而在日常应用中，遇到问题，我们往往需要借助搜索引擎来解决。那么，搜索引擎的快速搜索有什么技巧吗？</p><hr><h1 id="1-限定关键词"><a href="#1-限定关键词" class="headerlink" title="1. 限定关键词"></a>1. 限定关键词</h1><p>即不使用默认的模糊搜索，使用精确搜索。<br>在搜索词两边加上双引号””如</p><div class="code-wrapper"><pre><code class="hljs">&quot;sth&quot;&quot;张三&quot;</code></pre></div><h1 id="2-限定标题"><a href="#2-限定标题" class="headerlink" title="2. 限定标题"></a>2. 限定标题</h1><p>要求网页的标题中包含搜索的关键词</p><div class="code-wrapper"><pre><code class="hljs">intitle:sthintitle:&quot;张三&quot; </code></pre></div><h1 id="3-限定标题多个关键词"><a href="#3-限定标题多个关键词" class="headerlink" title="3. 限定标题多个关键词"></a>3. 限定标题多个关键词</h1><p>多个关键词都包含在网页标题中 </p><div class="code-wrapper"><pre><code class="hljs">allintitle:sth1 sth2allintitle：张三 李四</code></pre></div><h1 id="4-限定（文章）内容关键词"><a href="#4-限定（文章）内容关键词" class="headerlink" title="4. 限定（文章）内容关键词"></a>4. 限定（文章）内容关键词</h1><p>要求网页的内容中包含搜索的关键词</p><div class="code-wrapper"><pre><code class="hljs">intext:sthintext:&quot;池晨晨&quot; &quot;浙江大学&quot;</code></pre></div><h1 id="5-限定网址关键词"><a href="#5-限定网址关键词" class="headerlink" title="5. 限定网址关键词"></a>5. 限定网址关键词</h1><p>要求网页的网址中包含搜索的关键词</p><div class="code-wrapper"><pre><code class="hljs">inurl:sthinurl: CCTV</code></pre></div><h1 id="6-限定网址来源"><a href="#6-限定网址来源" class="headerlink" title="6. 限定网址来源"></a>6. 限定网址来源</h1><p>要求搜索的网页来源中包含搜索的关键词</p><div class="code-wrapper"><pre><code class="hljs">site: sthsite: zhihu.com//搜索的结果来源于知乎如：2024推荐免试 site:zju.edu.cn</code></pre></div><h1 id="7-限定图片尺寸"><a href="#7-限定图片尺寸" class="headerlink" title="7. 限定图片尺寸"></a>7. 限定图片尺寸</h1><p>要求搜索的图片尺寸中包含搜索的关键词</p><div class="code-wrapper"><pre><code class="hljs">imagesize: 2560×1440</code></pre></div><h1 id="8-限定文件格式："><a href="#8-限定文件格式：" class="headerlink" title="8. 限定文件格式："></a>8. 限定文件格式：</h1><p>要求搜索的文件格式</p><div class="code-wrapper"><pre><code class="hljs">filetype:pdf如了解某个行业的报告：母婴行业:2023 filetype:pdf</code></pre></div><h1 id="9-油管视频下载"><a href="#9-油管视频下载" class="headerlink" title="9. 油管视频下载"></a>9. 油管视频下载</h1><p>点击网址栏，在www.和you之间加上9x，按回车<br>或者用saveTube</p><h1 id="10-chatGPT"><a href="#10-chatGPT" class="headerlink" title="10. chatGPT"></a>10. chatGPT</h1><h2 id="10-1-扮演专家角色"><a href="#10-1-扮演专家角色" class="headerlink" title="10.1 扮演专家角色"></a>10.1 扮演专家角色</h2><p>问：你是个有 20 年从业经验的世界 500 强的营销顾问，我现在开了个叫“蜜雪冰城”的评价奶茶店，请帮我想三个营销推广的主题</p><p>答：当然，作为一位有 20 年从业经验的营销专家，我非常高兴为你的奶茶店“雪冰城”设计三个营销推广主题。以下是针对不同消费者群体和市场环境的主题方案，</p><h2 id="10-2-告诉chatGPT自己的角色"><a href="#10-2-告诉chatGPT自己的角色" class="headerlink" title="10.2 告诉chatGPT自己的角色"></a>10.2 告诉chatGPT自己的角色</h2><p>问：我是个正在学习python的无其他代码经验的初学者，我希望对一个csv格式的用户调研数据进行分析，请告诉我应该使用哪些工具去辅助我进行分析</p><p>答：对于初学者而言， Python 已经为处理和分析 CSV 文件提供了很多实用的工具。特别是，pandas 库是非常受欢迎且功能强大的数据分析工具。我推荐以下步骤帮助你分析csv数据</p><h2 id="10-3-期望的回答长度"><a href="#10-3-期望的回答长度" class="headerlink" title="10.3 期望的回答长度"></a>10.3 期望的回答长度</h2><p>问：写一篇 800 字的向非物理与材料专业读者介绍超导材料发展历史的文章？</p><h2 id="10-4-一步步思考"><a href="#10-4-一步步思考" class="headerlink" title="10.4 一步步思考"></a>10.4 一步步思考</h2><p>问：一步步思考，解答以下问题：甲和乙两个乡村图书室共有 5000 本藏书，其中甲图书室的藏书比乙图书室多 3x 本。现从甲书室中取出 150 本书放入乙图书室后，甲图书室的藏书仍比乙图书室多本。问甲图书室原有图书多少本？</p><p>A. 2500</p><p>B. 2750</p><p>C. 2950</p><p>D. 3500</p><p>答：我们可以一步步地用代数来解答这个问题。设甲图书室的图书数员为a本，乙图书室的图书数员为b本。根据题意，我们可以建立以下方程组．</p><ol><li>a + b &#x3D; 5000a &#x3D; b + 3</li><li>a &#x3D; b + 3x</li></ol><h2 id="10-5-明确你的要求和目的"><a href="#10-5-明确你的要求和目的" class="headerlink" title="10.5 明确你的要求和目的"></a>10.5 明确你的要求和目的</h2><p>chatGPT并不一定能准确的猜出你的要求</p><h2 id="10-6-提供充分的背景信息"><a href="#10-6-提供充分的背景信息" class="headerlink" title="10.6 提供充分的背景信息"></a>10.6 提供充分的背景信息</h2><p>告诉它为什么这么做，面临的背景是什么</p><h2 id="10-7-始终结构化思考你的prompt"><a href="#10-7-始终结构化思考你的prompt" class="headerlink" title="10.7 始终结构化思考你的prompt"></a>10.7 始终结构化思考你的prompt</h2><table><thead><tr><th>名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>指令词(lnstruction)</td><td>引导模型理解您所需任务或问题的词汇，帮助模型准确理解需求。</td><td>“简述”、”解释”、”翻译”、”总结”、”润色”写一篇文章”等。</td></tr><tr><td>输入 (lnput Data)</td><td>提供给模型的问题或具体内容，应清晰、完整以确保模型生成满意答案。</td><td>当需要总结时，提供的文本；当需要编写 SQL 代码时，提供的数据库表和字段信息。</td></tr><tr><td>背景 (Context) ·可选</td><td>与任务相关的其他信息，提供额外信息以帮助模型更好地理解需求。</td><td>同样是写关于量子计算的科普文章，是写给小学生还是物理专业大学生，得到的内容会完全不同。</td></tr><tr><td>输出要求 (Outputindicator) ·可选</td><td>对模型生成答案的格式、长度等方面的限制。</td><td>“用 50 字以内简述”、”请按以下格式回答： 1.材料… 2.步骤一… 3．步骤二”等。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>高效技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
